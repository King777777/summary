# JS原型链

先从一个简单例子开始

~~~js
function Foo(){}
let f1 = new Foo();
~~~

上面两行代码，分别定义了一个构造函数Foo，并用new关键字实例化出来一个对象，new操作符将函数作为构造器调用的过程：**函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this指向新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用**，背后的原型指向如下图

![image-20220213165010738](https://gitee.com/lwq1229/picture/raw/master/img/image-20220213165010738.png)

## **2.\__proto__属性**

首先，我们需要牢记两点，1.**\__proto__和constructor属性是对象所独有的**，2.**prototype属性是函数所独有的，同时函数也是一个对象，所以函数也有proto和constructor属性，**上图有点复杂，我们把它们按照属性拆开

![image-20220213170342067](https://gitee.com/lwq1229/picture/raw/master/img/image-20220213170342067.png)

第一，我们仅留下\__proto__属性,它是对象所独有的，可以看到**对象通过此属性来指向另一个对象**，即指向它们的原型对象（也可以理解为父对象），那么原型对象有啥么用呢，作用就是，**当访问一个对象的属性时，如果当前对象没有这个属性，那么就去它proto属性所指向的原型对象(父对象)去找，如果父对象中也不存在，就去爷爷对象中找，就这样一直找下去，最后到null为止**，这样的一条链子就是原型链，实际上和java，c++这种面向对象的语言类似，

像平时我们使用的字符串方法，数组方法，对象方法，函数方法都是靠proto属性继承来的

### prototype

第二，我们再来看看**函数（函数也是对象）所独有的prototype属性**，它所组成的指向图

![image-20220213171648093](https://gitee.com/lwq1229/picture/raw/master/img/image-20220213171648093.png)

可以看到指向关系为 **一个函数指向它的原型对象**，所以函数的prototype属性和它实例化对象的proto属性指向一致，均指向原型对象，那它的作用是？，**让该函数的所有实例化对象可以找到公用的方法和属性，任何函数在创建时，都会创建该函数的prototype对象**

## constructor属性

![image-20220213172324276](https://gitee.com/lwq1229/picture/raw/master/img/image-20220213172324276.png)

constructor是对象所独有的，它从一个对象指向一个函数，**含义就是指向该对象的构造函数**，每个对象都有构造函数（本身拥有或者继承而来，继承而来的要结合proto属性才能看更清楚），**所以可以看到Function这个对象比较特殊，构造函数指向自己，所有的函数和对象最终都是Function构造函数而来，所以constructor属性的终点就是Function()**

![image-20220213173021143](https://gitee.com/lwq1229/picture/raw/master/img/image-20220213173021143.png)

## 总结

1. 我们牢记两点，\__proto__和constructor属性是对象独有的；prototype属性是函数所独有的，但函数也是一种对象，所以函数也有proto和constructor属性
2. __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。
3. `prototype`属性的**作用**就是让该函数所实例化的对象们都可以找到公用的属性和方法，即`f1.__proto__ === Foo.prototype`。
4. `constructor`属性的含义就是**指向该对象的构造函数**，所有函数（此时看成对象了）最终的构造函数都指向**Function**。

## 实现一个继承

~~~js
function inherit(Child, Parent) {
     // 继承原型上的属性 
    Child.prototype = Object.create(Parent.prototype)
     // 修复 constructor
    Child.prototype.constructor = Child
    // 存储超类
    Child.super = Parent
    // 静态属性继承
    if (Object.setPrototypeOf) {
        // setPrototypeOf es6
        Object.setPrototypeOf(Child, Parent)
    } else if (Child.__proto__) {
        // __proto__ es6 引入，但是部分浏览器早已支持
        Child.__proto__ = Parent
    } else {
        // 兼容 IE10 等陈旧浏览器
        // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法
        for (var k in Parent) {
            if (Parent.hasOwnProperty(k) && !(k in Child)) {
                Child[k] = Parent[k]
            }
        }
    }
}

~~~

