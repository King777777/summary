# 防抖和节流

防抖和节流都是使用定时器来优化高频事件的一种手段。防抖是针对频繁触发，但其实只有最后一次是有效的场景。节流，跟字面意思一样，通过限制高频事件的执行频率来达到优化的目的。

举几个例子

防抖：

1. 搜索框的请求，我们使用防抖来减少不必要的请求次数，其实只有最后一次需要
2. 提交表单，疯狂点击提交，其实只要一次就好，此使用防抖
3. 登录的时候，其实也是提交请求，只需最后一次

节流：

1. 疯狂点击鼠标，比如一秒点击10次，但使用节流限制响应1一秒5次200ms
2. 鼠标的移动事件，限制事件的响应次数，不然太多了
3. 窗口的resize事件，滚动事件，限制响应频率

## 防抖

**防抖**：**是当事件被触发时，设定一个周期来延迟执行，若期间又被触发，则重新设定周期，直到周期结束，执行动作。**



**下面是一个例子，鼠标在div上移动，但是我们需求是只要最后一次鼠标位置即可，这种情况就需要用防抖**

如果没用防抖则是下面这样。

![GIF 2022-2-28 21-54-29](https://gitee.com/lwq1229/picture/raw/master/img/GIF%202022-2-28%2021-54-29.gif)

当把鼠标放到div上移动时，坐标变化非常快，也就是说事件触发的频率特别高，这就好比用户的输入导致的请求次数特别高一样，这显然不是很合理，**理想状态应该是，用户快速输入完后，我们只要请求一次接口**。这里也是，只有当鼠标停下来的事件大于定时器周期才执行函数。

一个简单的防抖如下（防抖还分立即执行和非立即执行，后面使用lodash就不深入了，知道大概即可）

~~~js
function debounce(func, delay) {
  let timeout;
  return function () {
    clearTimeout(timeout); // 如果持续触发，那么就清除定时器，定时器的回调就不会执行。
    timeout = setTimeout(() => { // 这里使用箭头函数就不用在外层获取this和arguments了
      func.apply(this, arguments);
    }, delay);
  };
}
~~~

完整代码

~~~js
import React, { Component } from 'react';
function debounce(func, delay) {
  let timeout;
  return function () {
    clearTimeout(timeout); // 如果持续触发，那么就清除定时器，定时器的回调就不会执行。
    timeout = setTimeout(() => { // 这里使用箭头函数就不用在外层获取this和arguments了
      func.apply(this, arguments);
    }, delay);
  };
}
export default class Deb extends Component {
  constructor(props) {
    super(props);
    this.state = {
      x: 0,
      y: 0
    }
  }
  
  paint = debounce((x, y) => {
      this.setState({ x: x, y: y})
    }, 500);
  
  countPlus = (e) => {
    let x = e.clientX;
    let y = e.clientY;
    this.paint(x,y);
  }
  render() {
    return (
      <div style={{ height: '100vh' }} onMouseMove={this.countPlus}>
        <h1>X: {this.state.x}</h1>
        <h1>Y: {this.state.y}</h1>
      </div>);
  }
}
~~~

效果如下,可以看到鼠标移动过程中不会记录坐标，停顿超过预设周期才行

![GIF 2022-2-28 22-08-48](https://gitee.com/lwq1229/picture/raw/master/img/GIF%202022-2-28%2022-08-48.gif)

## 节流

节流是减少函数执行频率的手段

场景、概念都讲过了，直接上代码

代码思路就是判断有无定时器，有定时器就直接不执行，没有就创建一个，在时间到达后执行函数并设置定时器为null，只有定时器销毁后才能开始下一个周期

节流这里有个大坑就是在清楚 计时器时不是用clearTimeout，我打印了下发现，怪不得每次就执行一次，所以手动置为null



![image-20220228230650452](https://gitee.com/lwq1229/picture/raw/master/img/image-20220228230650452.png)

~~~js
function throttle1(func, wait) {
    let timeout;
    return function() {
        // 判断是否有定时器
        let context = this;
        let args = arguments;
    console.log(Object.prototype.toString.call(timeout));
         console.log(!!timeout);
        console.log(timeout);
        if (!timeout) {
            // 没有就创建一个
            timeout = setTimeout(function(){
               //delay时间间隔后清除定时器
              // clearTimeout(timeout);
                timeout = null;
                func.apply(context, args)
            }, wait)
        }

    }
}

~~~

代码如下

~~~js
import React, { Component } from 'react';
function throttle(func, wait) {
    let timeout;
    return function() {
        // 判断是否有定时器
        let context = this;
        let args = arguments;
        console.log(!!timeout);
        console.log(timeout);
        console.log(Object.prototype.toString.call(timeout));
        if (!timeout) {
            // 没有就创建一个
            timeout = setTimeout(function(){
               //delay时间间隔后清除定时器
              // clearTimeout(timeout);
                timeout = null;
                func.apply(context, args)
            }, wait)
        }

    }
}

export default class Deb extends Component {
  constructor(props) {
    super(props);
    this.state = {
      x: 0,
      y: 0
    }
  }

  paint = throttle((x, y) => {
      this.setState({ x: x, y: y})
    }, 2000);

  countPlus = (e) => {
    let x = e.clientX;
    let y = e.clientY;
    this.paint(x,y);
  }
  render() {
    return (
      <div style={{ height: '100vh' }} onMouseMove={this.countPlus}>
        <h1>X: {this.state.x}</h1>
        <h1>Y: {this.state.y}</h1>
      </div>);
  }
}
~~~

效果如下，两秒记录一次

![GIF 2022-2-28 23-10-20](https://gitee.com/lwq1229/picture/raw/master/img/GIF%202022-2-28%2023-10-20.gif)

## lodash

但是呢，在实际项目中建议使用第三方库，功能更多而且更可靠

但是我在用的时候发现个问题，就是reactv16和v17使用上有点差别，如下



V17才可以这样，在V16里e.target是空的，请注意!!!

![image20220228165030649](https://gitee.com/lwq1229/picture/raw/master/img/image-20220228165030649.png)

V16写法

![image20220228165145610](https://gitee.com/lwq1229/picture/raw/master/img/image-20220228165145610.png)

![image20220228165217823](https://gitee.com/lwq1229/picture/raw/master/img/image-20220228165217823.png)

![image-20220228165230921)](https://gitee.com/lwq1229/picture/raw/master/img/image-20220228165230921.png)
