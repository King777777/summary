# 对象引用和复制

对象是通过引用来存储和复制的

~~~js
let user = {
    name 'John'
}
~~~

这里的**user是一个指向对象的引用**，赋值给user的是 **该对象在内存中的地址**

![image-20220612144712798](https://lwq-img-1312073911.cos.ap-nanjing.myqcloud.com/imgimage-20220612144712798.png)

**当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。**

例如：

```javascript
let user = { name: "John" };

let admin = user; // 复制引用
```

![image-20220612144812320](https://lwq-img-1312073911.cos.ap-nanjing.myqcloud.com/imgimage-20220612144812320.png)

正如你所看到的，这里仍然只有一个对象，但现在有两个引用它的变量。

我们可以通过其中任意一个变量来访问该对象并修改它的内容：

```javascript
let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // 通过 "admin" 引用来修改

alert(user.name); // 'Pete'，修改能通过 "user" 引用看到
```

**通过引用比较**

只有引用执向同一个对象时，才会相等

```javascript
let a = {};
let b = a; // 复制引用

alert( a == b ); // true，都引用同一对象
alert( a === b ); // true
```

而这里两个独立的对象则并不相等，即使它们看起来很像（都为空）：

```javascript
let a = {};
let b = {}; // 两个独立的对象

alert( a == b ); // false
```

## **对象克隆与合并，Object.assign**

### for in克隆

克隆一个对象，可以先创建一个空对象，然后用for in遍历要克隆的对象，赋值给空对象

~~~js
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 新的空对象

// 将 user 中所有的属性拷贝到其中
for (let key in user) {
  clone[key] = user[key];
}

// 现在 clone 是带有相同内容的完全独立的对象
clone.name = "Pete"; // 改变了其中的数据

alert( user.name ); // 原来的对象中的 name 属性依然是 John
~~~

### Object.assign克隆

**使用Object.assign可以合并多个对象并返回合并后的对象**

语法：

~~~js
Object.assign(dest, [src1, src2...]);
~~~

1. dest指目标对象
2. src1，src2指的是源对象
3. 该方法将所有源对象的属性拷贝到目标对象 `dest` 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。
4. 该方法最后返回dest的引用

例如，我们可以用它**来合并多个对象**：

```javascript
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中
Object.assign(user, permissions1, permissions2);

// 现在 user = { name: "John", canView: true, canEdit: true }
```

使用Object.assign克隆

我们也可以用 Object.assign 代替 for..in 循环来进行简单克隆：

~~~js


let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);
~~~

### 使用spread克隆

示例如下

~~~js
let let user = {
  name: "John",
  age: 30
};

let clone = {...user};// 克隆出一个新对象
~~~

## 深克隆

**到现在为止，我们都假设 `user` 的所有属性均为原始类型。但属性可以是对其他对象的引用。那应该怎样处理它们呢？**

例如：

```javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
```

现在这样拷贝 `clone.sizes = user.sizes` 已经不足够了，因为 `user.sizes` 是个对象，它会以引用形式被拷贝。因此 `clone` 和 `user` 会共用一个 sizes：

就像这样：

```javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true，同一个对象

// user 和 clone 分享同一个 sizes
user.sizes.width++;       // 通过其中一个改变属性值
alert(clone.sizes.width); // 51，能从另外一个看到变更的结果
```

**为了解决这个问题，我们应该使用一个拷贝循环来检查 `user[key]` 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。**

我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 [lodash](https://lodash.com/) 库的 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)。

**或者是使用简单的JSON.parse(JSON.stringify())**
